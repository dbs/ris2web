#!/usr/bin/env python3

"""
pip install pyzotero


# zotero.Zotero.items returns a data list as follows:
{
    "data": {
        "DOI": "10.7202/027620ar",
        "ISSN": "0034-379X, 1703-8138",
        "abstractNote": "",
        "accessDate": "2016-11-24T22:09:56Z",
        "archive": "",
        "archiveLocation": "",
        "callNumber": "",
        "collections": [
            "GAZFJMGC"
        ],
        "creators": [
            {
                "creatorType": "author",
                "firstName": "John H. G.",
                "lastName": "Crispo"
            }
        ],
        "date": "1965",
        "dateAdded": "2016-11-24T22:09:56Z",
        "dateModified": "2016-11-24T22:10:18Z",
        "extra": "",
        "issue": "4",
        "itemType": "journalArticle",
        "journalAbbreviation": "",
        "key": "RWDBFFEU",
        "language": "en",
        "libraryCatalog": "CrossRef",
        "pages": "700-706",
        "publicationTitle": "Relations industrielles",
        "relations": {},
        "rights": "",
        "series": "",
        "seriesText": "",
        "seriesTitle": "",
        "shortTitle": "Looking Back and Looking Forward",
        "tags": [],
        "title": "Looking Back and Looking Forward : Can Organized Labour Stand the Test of Time?",
        "url": "http://id.erudit.org/iderudit/027620ar",
        "version": 14527,
        "volume": "20"
    },
    "key": "RWDBFFEU",
    "library": {
        "id": 290262,
        "links": {
            "alternate": {
                "href": "https://www.zotero.org/groups/canadian_labour_studies_bibliography",
                "type": "text/html"
            }
        },
        "name": "Canadian Labour Studies Bibliography",
        "type": "group"
    },
    "links": {
        "alternate": {
            "href": "https://www.zotero.org/groups/canadian_labour_studies_bibliography/items/RWDBFFEU",
            "type": "text/html"
        },
        "self": {
            "href": "https://api.zotero.org/groups/290262/items/RWDBFFEU",
            "type": "application/json"
        }
    },
    "meta": {
        "createdByUser": {
            "id": 3393813,
            "links": {
                "alternate": {
                    "href": "https://www.zotero.org/erinvader",
                    "type": "text/html"
                }
            },
            "name": "",
            "username": "ErinVader"
        },
        "creatorSummary": "Crispo",
        "numChildren": 0,
        "parsedDate": "1965"
    },
    "version": 14527
}
"""

from pyzotero import zotero
import datetime
import json
import psycopg2
import configparser
from os.path import abspath, dirname

class ZoteroParser:
    """Read a Zotero item and parse it into its unique fields

    Currently suffers a bit too much from its RIS background
    """

    # We expect each of these fields to appear only once for a given citation
    core_map = {
        'abstractNote': 'abstract',
        'accessDate': 'access_date',
        'callNumber': 'call_number',
        'date': 'pub_date',
        #'date': 'pub_year',
        'DOI': 'doi',
        'edition': 'edition',
        'endPage': 'end_page', # we get this from parsing
        'ISBN': 'isbn_issn',
        'ISSN': 'isbn_issn',
        'issue': 'issue_number',
        'itemType': 'doc_type', # type of the cited document
        'journalAbbreviation': 'alternate_title', # often abbrev. journal or book title
        'key': 'zotero_key',
        'language': 'language',
        'libraryCatalog': 'pub_database',
        'pages': 'start_page',
        'numPages': 'start_page',
        'place': 'pub_place', # book
        'publicationTitle': 'pub_title',
        'publisher': 'publisher', # book
        'rights': 'rights',
        'seriesNumber': 'id_number',
        'series': 'series',
        #'series': 'title2',
        #'series': 'title3',
        'shortTitle': 'short_title', # often abbrev. journal or book title
        'thesisType': 'work_type',
        'title': 'title',
        #'url': 'local_url',
        'university': 'publisher',
        'url': 'url',
        'volume': 'volume'
    }

    # multiple authors / editors per citation
    # see http://refdb.sourceforge.net/manual/ch07.html#sect1-ris-format
    # but Zotero exports "series_editor" as A2 and "editor" as A3, argh
    author_map = {
        'AU': 'author',
        'A3': 'editor',
        'A2': 'series_editor',
        'A4': 'translator',
        'A5': 'contributor'
    }

    def __init__(self, item, config):
        "Parse it up"

        self.add_date = datetime.datetime.strptime(item['data']['dateAdded'], '%Y-%m-%dT%H:%M:%SZ')
        self.cite = {}
        self.authors = []
        self.keywords = []
        self.config = config
        self.get_db()
        if item['data']['itemType'] == 'attachment':
            return
        for zot, ris in ZoteroParser.core_map.items():
            if zot in item['data']:
                z = item['data'][zot]
                if z == "" and ris not in self.cite:
                    self.cite[ris] = None
                else:
                    self.cite[ris] = z
            elif ris not in self.cite:
                self.cite[ris] = None

        if 'creators' in item['data']:
            self.authorship(item)

        if 'tags' in item['data']:
            self.parse_tags(item)

        self.map_doc_type()
        self.map_pages()

        #print(json.dumps(self.cite, sort_keys=True, indent=4))

        self.cite['source'] = json.dumps(item['data'])
        #print(json.dumps(self.authors))

    def map_doc_type(self):
        "Map Zotero doc types to RIS doc types"

        z_to_r = {
            'journalArticle': 'JOUR',
            'book': 'BOOK',
            'bookSection': 'CHAP',
            'thesis': 'THES',
            'report': 'RPRT',
            'webpage': 'ELEC',
            'magazineArticle': 'JOUR',
            'newspaperArticle': 'JOUR',
            'film': 'MPCT',
            'videoRecording': 'VIDEO',
            'map': 'MAP',
            'blogPost': 'ELEC',
            'encyclopediaArticle': 'JOUR',
            'conferencePaper': 'JOUR'
        }

        if self.cite['doc_type'] in z_to_r:
            self.cite['doc_type'] = z_to_r[self.cite['doc_type']]

    def map_pages(self):
        "Map start/end pages"

        if self.cite['start_page'] is not None and '-' in self.cite['start_page']:
            self.cite['start_page'], self.cite['end_page'] = self.cite['start_page'].split('-', maxsplit=1)

    def parse_tags(self, item):
        "Parse out keywords for the item"

        for t in item['data']['tags']:
            self.keywords.append(t['tag'])

    def authorship(self, item):
        "Parse out different types of authors"

        for a in item['data']['creators']:
            #print("\t%s" % (json.dumps(a)))
            if 'firstName' in a:
                self.authors.append({'creator': a['creatorType'], 'name': "%s, %s" % (a['lastName'], a['firstName']), 'first_name': a['firstName'], 'last_name': a['lastName']})
            else:
                self.authors.append({'creator': a['creatorType'], 'name': a['name']})

    def insert_citation(self):
        cur = self.conn.cursor()
        cur.execute("""
INSERT INTO citations(abstract, access_date, alternate_title, call_number, doc_type, doi, edition, end_page, id_number, isbn_issn, issue_number, language, pub_database, pub_date, publisher, pub_place, pub_title, short_title, start_page, title, series, url, volume, work_type, zotero_key, source)
VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);""",
            (self.cite['abstract'], self.cite['access_date'], self.cite['alternate_title'], self.cite['call_number'], self.cite['doc_type'], self.cite['doi'], self.cite['edition'], self.cite['end_page'], self.cite['id_number'], self.cite['isbn_issn'], self.cite['issue_number'], self.cite['language'], self.cite['pub_database'], self.cite['pub_date'], self.cite['publisher'], self.cite['pub_place'], self.cite['pub_title'], self.cite['short_title'], self.cite['start_page'], self.cite['title'], self.cite['series'], self.cite['url'], self.cite['volume'], self.cite['work_type'], self.cite['zotero_key'], self.cite['source'])
        )
        self.conn.commit()
        cur.close()

    def update_citation(self):
        cur = self.conn.cursor()

        # Start with checking for the Zotero key
        if self.cite['zotero_key'] is not None:
            cur.execute("SELECT id FROM citations WHERE zotero_key = %s", (self.cite['zotero_key'],))
            res = cur.fetchone()

        if cur.rowcount != 1:
            cur.execute("""
                SELECT id FROM citations WHERE title = %s AND doc_type = %s AND start_page = %s
            """, (self.cite['title'], self.cite['doc_type'], self.cite['start_page']))

            res = cur.fetchone()
            if cur.rowcount > 1 or res is None:
                cur.close()
                return False

        cur.execute("UPDATE citations SET abstract= %s, access_date= %s, alternate_title= %s, call_number= %s, doc_type= %s, doi= %s, edition= %s, end_page = %s, id_number= %s, isbn_issn= %s, issue_number= %s, language= %s, pub_database= %s, pub_date= %s, pub_title= %s, publisher= %s, pub_place= %s, short_title= %s, start_page= %s, title= %s, series= %s, url= %s, volume= %s, work_type= %s, zotero_key= %s, source = %s WHERE id = %s",
            (self.cite['abstract'], self.cite['access_date'], self.cite['alternate_title'], self.cite['call_number'], self.cite['doc_type'], self.cite['doi'], self.cite['edition'], self.cite['end_page'], self.cite['id_number'], self.cite['isbn_issn'], self.cite['issue_number'], self.cite['language'], self.cite['pub_database'], self.cite['pub_date'], self.cite['pub_title'], self.cite['publisher'], self.cite['pub_place'], self.cite['short_title'], self.cite['start_page'], self.cite['title'], self.cite['series'], self.cite['url'], self.cite['volume'], self.cite['work_type'], self.cite['zotero_key'], self.cite['source'], res[0])
        )

        self.conn.commit()
        cur.close()
        return True

    def insert_authors(self):
        cur = self.conn.cursor()
        for author in self.authors:
            if 'last_name' in author:
                cur.execute("INSERT INTO zotero_cites_to_authors(zotero_key, author_type, name, last_name, first_name) VALUES (%s, %s, %s, %s, %s)", (self.cite['zotero_key'], author['creator'], author['name'], author['last_name'], author['first_name']))
            else:
                cur.execute("INSERT INTO zotero_cites_to_authors(zotero_key, author_type, name) VALUES (%s, %s, %s)", (self.cite['zotero_key'], author['creator'], author['name']))
        self.conn.commit()
        cur.close()

    def insert_keywords(self):
        cur = self.conn.cursor()
        for kw in self.keywords:
            cur.execute("INSERT INTO zotero_keywords(zotero_key, keywords) VALUES (%s, %s)", (self.cite['zotero_key'], kw))
        self.conn.commit()
        cur.close()

    def get_db(self):
        """
        Get a database connection

        With a host attribute in the mix, you could connect to a remote
        database, but then you would have to set up .pgpass or add a
        password parameter, so let's keep it simple.
        """

        try:
            self.conn = psycopg2.connect(
                database=self.config['database']['dbname'],
                user=self.config['database']['dbuser']
            )
        except Exception as e:
            print(e)

def get_db(config):
    """
    Get a database connection

    With a host attribute in the mix, you could connect to a remote
    database, but then you would have to set up .pgpass or add a
    password parameter, so let's keep it simple.
    """

    try:
        conn = psycopg2.connect(
            database=config['database']['dbname'],
            user=config['database']['dbuser']
        )
    except Exception as e:
        print(e)

    return conn

def prep_db(config):
    "Extend the database to support richer Zotero API data"

    # We're going to start tracking the citations by their zotero key:

    stmts = [
        "ALTER TABLE citations ADD COLUMN zotero_key TEXT;",
        "ALTER TABLE citations ADD COLUMN source JSONB;",
        "CREATE INDEX ON citations(zotero_key);",
        r"UPDATE citations SET zotero_key = 'MNR2E9G7' WHERE title = 'Comprendre le comportement de l''individu au travail: un schema d''integration // Review';",
        r"UPDATE citations SET zotero_key = 'HKPVMMVR' WHERE title = '[Au-dela de l''emploi: transformations du travail & devenir du droit du travail en Europe]' AND pub_date ~ '1999';",
        r"UPDATE citations SET zotero_key = '8IZT5G6M' WHERE title = 'Critique du droit du travail // Review' AND pub_date ~ '1995';",
        r"UPDATE citations SET zotero_key = 'RPKWMA9Z' WHERE title = '[Droits en synergie sur le travail: elements de droits international & compare du travail]' AND pub_date ~ '1998';",
        r"UPDATE citations SET zotero_key = '7BTUBT86' WHERE title = 'Le droit des salaries a la negociation collective: principe general du droit // Review' AND pub_date ~ '1995';",
        r"UPDATE citations SET zotero_key = 'IMURBAPS' WHERE title = 'Les dilemmes de l''ANACT: ambiguite ou complementarite? [L''accord nord-americain de cooperation dans le domaine du travail]' AND pub_date ~ '1999';",
        r"UPDATE citations SET zotero_key = 'XCVR3HWC' WHERE title = 'L''État, l''autonomie collective et le travailleur - Étude comparée du droit italien et du droit français de la représentativité syndicale' AND pub_date ~ '1997';",
        r"UPDATE citations SET zotero_key = 'HPH22NAD' WHERE title = '[Libertad sindical]' AND pub_date ~ '2000';",
        r"UPDATE citations SET zotero_key = '98X42ZCX' WHERE title = 'Syndicats et droit syndical:  Le droit syndical dans l''entreprise' AND pub_date ~ '1985';",
        r"UPDATE citations SET zotero_key = 'JKVT5E4T' WHERE title = '[The rise & development of collective labor law]' AND pub_date ~ '2001';",
        r"UPDATE citations SET zotero_key = 'SEK2ZV7H' WHERE title = 'Transformation de l''entreprise et representation syndicale' AND pub_date ~ '1993';",
        r"UPDATE citations SET zotero_key = 'WSBUS4M2' WHERE title = 'La Planification strategique des ressources humaines // Review' AND pub_date ~ '1992';",
        r"UPDATE citations SET zotero_key = 'C4K92P5M' WHERE title = 'Sayer, Derek. Capitalism And Modernity: An Excursus On Marx And Weber // Review' AND pub_date ~ '1991';",
        r"UPDATE citations SET zotero_key = 'GBFI9W6E' WHERE title = 'Esping-Andersen, Gosta. The Three Worlds Of Welfare Capitalism // Review' AND pub_date ~ '1992';",
        r"UPDATE citations SET zotero_key = '2T8TQAV3' WHERE title = 'Comparative Industrial Relations. Ideologies, Institutions, Practices and Problems under Social Systems with Special Reference to Socialist Planned Economies' AND pub_date ~ '1985';",
        r"UPDATE citations SET zotero_key = 'A2K78SKR' WHERE title = 'Mitarbeiter beteiligung. Grundlagen - Befunde - Modelle';",
        r"UPDATE citations SET zotero_key = '535SASAC' WHERE title = 'New Forms of Work Organization and thier Social and Economic Development';",
        r"UPDATE citations SET zotero_key = 'WMRCN7DN' WHERE title = 'Trade Unions : The logic of Collective Action' AND pub_date ~ '1984';",
        r"UPDATE citations SET zotero_key = '6H6S3ANE' WHERE title = 'Workplace Innovation in Canada. Reflections on the Past Prospects for the Future. A Study prepared for the Economic Council of Canada, Ottawa, Minister of Supply and Services Canada';",
        r"UPDATE citations SET zotero_key = '5FQCJMJH' WHERE title = 'Book notes' AND pub_date ~ '1989';",
        r"UPDATE citations SET zotero_key = 'FJQ743X2' WHERE title = 'Comparative Labour History: Australia and Canada' AND pub_date ~ '1996';",
        r"UPDATE citations SET zotero_key = 'B69TWSH8' WHERE title = 'Editor''s Note' AND pub_date ~ '1988' AND pub_date ~ 'Spring';",
        r"UPDATE citations SET zotero_key = '3TBZN432' WHERE title = 'Enjeux actuels de la formation professionnelle // Review' AND pub_date ~ '1994';",
        r"UPDATE citations SET zotero_key = 'JHKHUMZE' WHERE title = 'Lane, Christel. Management And Labour In Europe // Review' AND pub_date ~ '1991';",
        r"UPDATE citations SET zotero_key = '46AJPUFF' WHERE title = 'La sociologie des entreprises // Review' AND pub_date ~ '1996';",
        r"UPDATE citations SET zotero_key = 'CCENH72Z' WHERE title = 'Les apprentissages du changement dans l''entreprise // Review' AND pub_date ~ '1996';",
        r"UPDATE citations SET zotero_key = 'NJV89249' WHERE title = 'Modern capitalism: privatization, employee ownership & industrial democracy // Review' AND pub_date ~ '1996';",
        r"UPDATE citations SET zotero_key = 'T3ZU5PT6' WHERE title = 'Occupational subcultures in the workplace // Review' AND pub_date ~ '1995';",
        r"UPDATE citations SET zotero_key = 'BVI45GH5' WHERE title = 'On strong foundations: the BWIU & industrial relations in the Australian construction industry, 1942-1992 // Review' AND pub_date ~ '1996';",
        r"UPDATE citations SET zotero_key = 'MZNVG26X' WHERE title = 'Profit sharing: does it make a difference? // Review' AND pub_date ~ '1994';",
        r"UPDATE citations SET zotero_key = '4KJ4HQ5X' WHERE title = 'Projecting capitalism: a history of the internationalization of the construction industry // Review' AND pub_date ~ '1995';",
        r"UPDATE citations SET zotero_key = '2N7APD6K' WHERE title = 'Shadows of the mind: a search for the missing science of consciousness // Review' AND pub_date ~ '1995';",
        r"UPDATE citations SET zotero_key = 'QCZZ95UE' WHERE title = 'Understanding industrial organizations: theoretical perspectives in industrial sociology // Review' AND pub_date ~ '1994';",
    ]

    # This will enable us to insert the new citations, as well as a new
    # zotero_cites_to_authors table:

    stmts.append("CREATE TABLE zotero_cites_to_authors (zotero_key TEXT, author_type TEXT, name TEXT, first_name TEXT, last_name TEXT, author_id INT);")

    # Then we'll be able to normalize the authors with the existing authors table
    # (updating author_id), then map the authors to citations by ID in the
    # cites_to_author table.

    # We also want to automatically assign IDs for the new citations (6533 is the latest):
    stmts.append("CREATE SEQUENCE citations_id_seq;")
    stmts.append("SELECT SETVAL('citations_id_seq', MAX(id) + 1) FROM citations;")
    stmts.append("ALTER TABLE citations ALTER COLUMN id SET DEFAULT nextval('citations_id_seq');")

    # Prevent duplicate author/citation rows from new citations
    stmts.append("ALTER TABLE cites_to_authors ADD CONSTRAINT unique_cites_to_authors UNIQUE (citation, author_type, author);")

    # Store our keywords
    stmts.append("CREATE TABLE zotero_keywords(zotero_key TEXT, keywords TEXT)")

    conn = get_db(config)
    cur = conn.cursor()
    for stmt in stmts:
        cur.execute(stmt)
    conn.commit()
    cur.close()

def post_process(config):

    stmts = [
        r"""UPDATE citations
            SET url = regexp_replace(url, '\.librweb.laurentian.ca', '')
            WHERE url ~ 'librweb';""",
        r"UPDATE citations SET isbn_issn = regexp_replace(isbn_issn, E'^(\\d{4})(\\d{4})$', '\\1-\\2') WHERE isbn_issn ~ E'^\\d{8}$';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^(\\D+) (\\d{4})', E'\\2\/\/\/\\1') WHERE pub_date ~ E'^\\D';",
        "UPDATE citations SET title2 = pub_title WHERE doc_type = 'JOUR' AND title2 IS NULL AND pub_title IS NOT NULL;",
        "UPDATE zotero_cites_to_authors SET author_id = a.id FROM authors a WHERE a.author_name = name;",
        "INSERT INTO authors (author_name) SELECT DISTINCT name FROM zotero_cites_to_authors WHERE author_id IS NULL;",
        "UPDATE zotero_cites_to_authors SET author_id = a.id FROM authors a WHERE a.author_name = name AND author_id IS NULL;",
        "INSERT INTO cites_to_authors (citation, author_type, author) SELECT DISTINCT c.id, z.author_type, z.author_id FROM zotero_cites_to_authors z INNER JOIN citations c ON c.zotero_key = z.zotero_key WHERE c.zotero_key IS NOT NULL AND NOT EXISTS (SELECT citation, author_type, author FROM cites_to_authors WHERE citation = c.id AND author_type = z.author_type AND author = z.author_id);",
        r"""UPDATE citations
            SET title2 = 'Relations Industrielles / Industrial Relations'
            WHERE title2 ~* 'Relations Industrielles';""",
        r"""UPDATE citations
            SET title2 = 'Labour / Le Travail'
            WHERE title2 IN ('Labour/Le Travail');""",
        r"""UPDATE citations
            SET title2 = 'Socialist Studies / Études socialistes'
            WHERE title2 IN ('Socialist Studies/Études socialistes');""",
        r"""UPDATE citations SET language = 'English'
            WHERE language IN ('eng', 'en', 'en_ca', 'en-GB');""",
        r"""UPDATE citations SET language = 'English'
            WHERE language IS NULL;""",
        r"""UPDATE citations SET language = 'French'
            WHERE language IN ('fr', 'fre');""",
        r"""UPDATE citations SET language = 'Spanish'
            WHERE language IN ('sp');""",
        r"""UPDATE citations SET language = 'English, French'
            WHERE language IN ('en fr', 'eng; fre');""",
        r"""UPDATE citations SET language = 'French, English'
            WHERE language IN ('fr en');""",
        r"""UPDATE citations SET language = 'French, English, Spanish'
            WHERE language IN ('fr en sp');""",
        r"""UPDATE citations SET language = 'Italian'
            WHERE language IN ('It');""",
        r"""UPDATE citations
            SET publisher = 'Canadian Committee on Labour History'
            WHERE publisher = 'Committee on Canadian Labour History';""",
        r"""UPDATE citations SET series = title2
                WHERE doc_type IN ('BOOK', 'RPRT');""",
        r"""UPDATE citations SET series = title3
                WHERE doc_type IN ('CHAP');""",
        r"""UPDATE citations SET pub_title = title2
                WHERE doc_type IN ('JOUR', 'CHAP', 'NEWS', 'MGZN', 'ELEC');""",
        r"""UPDATE citations SET pub_title = title
                WHERE doc_type IN ('BOOK');""",
        r"""UPDATE citations SET kw_tsv = setweight(to_tsvector('english', title), 'A')
             || setweight(to_tsvector('english', COALESCE(abstract, '')), 'C');""",
        r"""UPDATE citations SET kw_tsv = kw_tsv || setweight(to_tsvector('english', COALESCE(
             (SELECT STRING_AGG(notes, ' ') FROM citation_notes WHERE citation = citations.id), '')), 'C');""",
        r"""UPDATE citations SET kw_tsv = kw_tsv || setweight(to_tsvector('english', COALESCE(
             (SELECT STRING_AGG(keywords, ' ') FROM citation_keywords WHERE citation = citations.id), '')), 'B');""",
        r"""UPDATE citations SET kw_tsv = kw_tsv || setweight(to_tsvector('english', COALESCE(
             (SELECT STRING_AGG(author_name, ' ') FROM authored_v WHERE citation = citations.id), '')), 'B');""",
         # TODO: handle notes directly during processing
        "INSERT INTO public.citation_notes (citation, notes) SELECT c.id, n.source::json->>'note' FROM citations n INNER JOIN citations c ON c.zotero_key = n.zotero_key WHERE n.doc_type = 'note' AND n.source::json->>'note' IS NOT NULL;",
        "DELETE FROM citations WHERE doc_type = 'note';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/01/\\1') WHERE pub_date ~* E'^Jan';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/02/\\1') WHERE pub_date ~* E'^Feb';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/03/\\1') WHERE pub_date ~* E'^Mar';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/04/\\1') WHERE pub_date ~* E'^Apr';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/05/\\1') WHERE pub_date ~* E'^May';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/06/\\1') WHERE pub_date ~* E'^Jun';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/07/\\1') WHERE pub_date ~* E'^Jul';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/08/\\1') WHERE pub_date ~* E'^Aug';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/09/\\1') WHERE pub_date ~* E'^Sep';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/10/\\1') WHERE pub_date ~* E'^Oct';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/11/\\1') WHERE pub_date ~* E'^Nov';",
        r"UPDATE citations SET pub_date = regexp_replace(pub_date, E'^.*? (\\d+).*? (\\d{4})', E'\\2/12/\\1') WHERE pub_date ~* E'^Dec';",
    ]

    conn = get_db(config)
    cur = conn.cursor()
    for stmt in stmts:
        cur.execute(stmt)
    conn.commit()
    cur.close()

def main():
    "Integrate the latest updates to the database"

    write_updates = False
    read_updates = True

    config = configparser.ConfigParser()
    config.read(abspath(dirname(__file__)) + '/config.ini')
    if write_updates:
        f = open('updates.json', 'w')

    try:
        prep_db(config)
    except Exception as e:
        print(e)

    stop_date = datetime.datetime.strptime(config['zotero']['stop_date'], "%Y-%m-%d")

    # Access our group
    zot = zotero.Zotero(config['zotero']['group'], 'group', config['zotero']['key'])

    # list_collections(zot)
    if read_updates:
        f = open('updates.json', 'r')
        items = json.load(f)
    else:
        items = zot.items(sort='dateModified', direction='desc', limit=100)
    # items = [zot.item('JC94RN9H')]
#    import requests
#    r = requests.get('https://api.zotero.org/groups/290262/items/2P9NSQ9M')
#    items = []
#    items.append(r.json())

    mod_date = datetime.datetime.now()
    while items and stop_date < mod_date:
        for i in items:
            if write_updates:
                f.write(json.dumps(i, sort_keys=True, indent=4))
            #print("%s %s" % (i['key'], i['data']['dateModified']))
            if i['data']['itemType'] == 'attachment':
                continue
            mod_date = datetime.datetime.strptime(i['data']['dateModified'], '%Y-%m-%dT%H:%M:%SZ')
            if stop_date > mod_date:
                continue
            process_item(i, config)
        if not read_updates:
            items = zot.follow()
        else:
            items = None

    try:
        post_process(config)
    except Exception as e:
        print(e)

def process_item(i, config):
    "Parse the item data and get it into the database"
    z = ZoteroParser(i, config)

    z.insert_authors()
    z.insert_keywords()
    if z.update_citation() is False:
        z.insert_citation()
    z.conn.close()

def list_collections(zot):
    "We have a lot of collections"
    c = zot.collections()
    x = 0
    for i in c:
        x += 1
        print(json.dumps(i, sort_keys=True, indent=4))
    c = zot.collections(start=x)
    for i in c:
        x += 1
        print(json.dumps(i, sort_keys=True, indent=4))
    c = zot.collections(start=x)
    for i in c:
        x += 1
        print(json.dumps(i, sort_keys=True, indent=4))
    print(x)


if __name__ == '__main__':
    main()
