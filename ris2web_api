#!/usr/bin/env python3

"""
pip install pyzotero

    UPDATE citations SET pub_date = regexp_replace(pub_date, E'^(\\D+) (\\d{4})', E'\\2\/\/\/\\1') WHERE pub_date ~ E'^\\D';
    UPDATE citations SET title2 = publisher WHERE doc_type = 'JOUR' AND publisher IS NOT NULL;
    UPDATE citations SET publisher = NULL WHERE doc_type = 'JOUR' AND publisher IS NOT NULL;

    UPDATE zotero_cites_to_authors SET author_id = a.id FROM authors a WHERE a.author_name = name;
    INSERT INTO authors (author_name) SELECT DISTINCT name FROM zotero_cites_to_authors WHERE author_id IS NULL;
    UPDATE zotero_cites_to_authors SET author_id = a.id FROM authors a WHERE a.author_name = name AND author_id IS NULL;
    INSERT INTO cites_to_authors (citation, author_type, author) SELECT DISTINCT c.id, z.author_type, z.author_id FROM zotero_cites_to_authors z INNER JOIN citations c ON c.zotero_key = z.zotero_key WHERE c.zotero_key IS NOT NULL;

We need to take care of notes during processing! Here's a post-loading hacky fix:
    INSERT INTO public.citation_notes (citation, notes) SELECT c.id, n.source::json->>'note' FROM citations n INNER JOIN citations c ON c.zotero_key = n.zotero_key WHERE n.doc_type = 'note' AND n.source::json->>'note' IS NOT NULL;
    DELETE FROM citations WHERE doc_type = 'note';

# zotero.Zotero.items returns a data list as follows:
{
    "data": {
        "DOI": "10.7202/027620ar",
        "ISSN": "0034-379X, 1703-8138",
        "abstractNote": "",
        "accessDate": "2016-11-24T22:09:56Z",
        "archive": "",
        "archiveLocation": "",
        "callNumber": "",
        "collections": [
            "GAZFJMGC"
        ],
        "creators": [
            {
                "creatorType": "author",
                "firstName": "John H. G.",
                "lastName": "Crispo"
            }
        ],
        "date": "1965",
        "dateAdded": "2016-11-24T22:09:56Z",
        "dateModified": "2016-11-24T22:10:18Z",
        "extra": "",
        "issue": "4",
        "itemType": "journalArticle",
        "journalAbbreviation": "",
        "key": "RWDBFFEU",
        "language": "en",
        "libraryCatalog": "CrossRef",
        "pages": "700-706",
        "publicationTitle": "Relations industrielles",
        "relations": {},
        "rights": "",
        "series": "",
        "seriesText": "",
        "seriesTitle": "",
        "shortTitle": "Looking Back and Looking Forward",
        "tags": [],
        "title": "Looking Back and Looking Forward : Can Organized Labour Stand the Test of Time?",
        "url": "http://id.erudit.org/iderudit/027620ar",
        "version": 14527,
        "volume": "20"
    },
    "key": "RWDBFFEU",
    "library": {
        "id": 290262,
        "links": {
            "alternate": {
                "href": "https://www.zotero.org/groups/canadian_labour_studies_bibliography",
                "type": "text/html"
            }
        },
        "name": "Canadian Labour Studies Bibliography",
        "type": "group"
    },
    "links": {
        "alternate": {
            "href": "https://www.zotero.org/groups/canadian_labour_studies_bibliography/items/RWDBFFEU",
            "type": "text/html"
        },
        "self": {
            "href": "https://api.zotero.org/groups/290262/items/RWDBFFEU",
            "type": "application/json"
        }
    },
    "meta": {
        "createdByUser": {
            "id": 3393813,
            "links": {
                "alternate": {
                    "href": "https://www.zotero.org/erinvader",
                    "type": "text/html"
                }
            },
            "name": "",
            "username": "ErinVader"
        },
        "creatorSummary": "Crispo",
        "numChildren": 0,
        "parsedDate": "1965"
    },
    "version": 14527
}
"""

from pyzotero import zotero
import datetime
import json
import psycopg2
import configparser
from os.path import abspath, dirname

class ZoteroParser:
    """Read a Zotero item and parse it into its unique fields

    Currently suffers a bit too much from its RIS background
    """

    # We expect each of these fields to appear only once for a given citation
    core_map = {
        'abstractNote': 'abstract',
        'accessDate': 'access_date',
        'callNumber': 'call_number',
        'date': 'pub_date',
        #'date': 'pub_year',
        'DOI': 'doi',
        'edition': 'edition',
        'endPage': 'end_page', # we get this from parsing
        'ISBN': 'isbn_issn',
        'ISSN': 'isbn_issn',
        'issue': 'issue_number',
        'itemType': 'doc_type', # type of the cited document
        'journalAbbreviation': 'alternate_title', # often abbrev. journal or book title
        'key': 'zotero_key',
        'language': 'language',
        'libraryCatalog': 'pub_database',
        'pages': 'start_page',
        'numPages': 'start_page',
        'place': 'pub_place', # book
        'publicationTitle': 'pub_title',
        'publisher': 'publisher', # book
        'rights': 'rights',
        'seriesNumber': 'id_number',
        'series': 'series',
        #'series': 'title2',
        #'series': 'title3',
        'shortTitle': 'short_title', # often abbrev. journal or book title
        'thesisType': 'work_type',
        'title': 'title',
        #'url': 'local_url',
        'university': 'publisher',
        'url': 'url',
        'volume': 'volume'
    }

    # multiple authors / editors per citation
    # see http://refdb.sourceforge.net/manual/ch07.html#sect1-ris-format
    # but Zotero exports "series_editor" as A2 and "editor" as A3, argh
    author_map = {
        'AU': 'author',
        'A3': 'editor',
        'A2': 'series_editor',
        'A4': 'translator',
        'A5': 'contributor'
    }

    def __init__(self, item, config):
        "Parse it up"

        self.add_date = datetime.datetime.strptime(item['data']['dateAdded'], '%Y-%m-%dT%H:%M:%SZ')
        self.cite = {}
        self.authors = []
        self.keywords = []
        self.config = config
        self.get_db()
        if item['data']['itemType'] == 'attachment':
            return
        for zot, ris in ZoteroParser.core_map.items():
            if zot in item['data']:
                z = item['data'][zot]
                if z == "" and ris not in self.cite:
                    self.cite[ris] = None
                else:
                    self.cite[ris] = z
            elif ris not in self.cite:
                self.cite[ris] = None

        if 'creators' in item['data']:
            self.authorship(item)

        if 'tags' in item['data']:
            self.parse_tags(item)

        self.map_doc_type()
        self.map_pages()

        print(json.dumps(self.cite, sort_keys=True, indent=4))

        self.cite['source'] = json.dumps(item['data'])
        #print(json.dumps(self.authors))

    def map_doc_type(self):
        "Map Zotero doc types to RIS doc types"

        z_to_r = {
            'journalArticle': 'JOUR',
            'book': 'BOOK',
            'bookSection': 'CHAP',
            'thesis': 'THES',
            'report': 'RPRT',
            'webpage': 'ELEC',
            'magazineArticle': 'JOUR',
            'newspaperArticle': 'JOUR',
            'film': 'MPCT',
            'videoRecording': 'VIDEO',
            'map': 'MAP',
            'blogPost': 'ELEC',
            'encyclopediaArticle': 'JOUR',
            'conferencePaper': 'JOUR'
        }

        if self.cite['doc_type'] in z_to_r:
            self.cite['doc_type'] = z_to_r[self.cite['doc_type']]

    def map_pages(self):
        "Map start/end pages"

        if '-' in self.cite['start_page']:
            self.cite['start_page'], self.cite['end_page'] = self.cite['start_page'].split('-')


    def parse_tags(self, item):
        "Parse out keywords for the item"

        for t in item['data']['tags']:
            self.keywords.append(t['tag'])

    def authorship(self, item):
        "Parse out different types of authors"

        for a in item['data']['creators']:
            #print("\t%s" % (json.dumps(a)))
            if 'firstName' in a:
                self.authors.append({'creator': a['creatorType'], 'name': "%s, %s" % (a['lastName'], a['firstName']), 'first_name': a['firstName'], 'last_name': a['lastName']})
            else:
                self.authors.append({'creator': a['creatorType'], 'name': a['name']})

    def insert_citation(self):
        cur = self.conn.cursor()
        cur.execute("""
INSERT INTO citations(abstract, access_date, alternate_title, call_number, doc_type, doi, edition, end_page, id_number, isbn_issn, issue_number, language, pub_database, pub_date, publisher, pub_place, pub_title, short_title, start_page, title, series, url, volume, work_type, zotero_key, source)
VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);""",
            (self.cite['abstract'], self.cite['access_date'], self.cite['alternate_title'], self.cite['call_number'], self.cite['doc_type'], self.cite['doi'], self.cite['edition'], self.cite['end_page'], self.cite['id_number'], self.cite['isbn_issn'], self.cite['issue_number'], self.cite['language'], self.cite['pub_database'], self.cite['pub_date'], self.cite['publisher'], self.cite['pub_place'], self.cite['pub_title'], self.cite['short_title'], self.cite['start_page'], self.cite['title'], self.cite['series'], self.cite['url'], self.cite['volume'], self.cite['work_type'], self.cite['zotero_key'], self.cite['source'])
        )
        self.conn.commit()
        cur.close()

    def update_citation(self):
        cur = self.conn.cursor()

        cur.execute("""
            SELECT id FROM citations WHERE title = %s AND doc_type = %s AND start_page = %s
        """, (self.cite['title'], self.cite['doc_type'], self.cite['start_page']))

        res = cur.fetchone()
        if cur.rowcount > 1 or res is None:
            cur.close()
            return

        cur.execute("UPDATE citations SET abstract= %s, access_date= %s, alternate_title= %s, call_number= %s, doc_type= %s, doi= %s, edition= %s, end_page = %s, id_number= %s, isbn_issn= %s, issue_number= %s, language= %s, pub_database= %s, pub_date= %s, pub_title= %s, publisher= %s, pub_place= %s, short_title= %s, start_page= %s, title= %s, series= %s, url= %s, volume= %s, work_type= %s, zotero_key= %s, source = %s WHERE id = %s",
            (self.cite['abstract'], self.cite['access_date'], self.cite['alternate_title'], self.cite['call_number'], self.cite['doc_type'], self.cite['doi'], self.cite['edition'], self.cite['end_page'], self.cite['id_number'], self.cite['isbn_issn'], self.cite['issue_number'], self.cite['language'], self.cite['pub_database'], self.cite['pub_date'], self.cite['pub_title'], self.cite['publisher'], self.cite['pub_place'], self.cite['short_title'], self.cite['start_page'], self.cite['title'], self.cite['series'], self.cite['url'], self.cite['volume'], self.cite['work_type'], self.cite['zotero_key'], self.cite['source'], res[0])
        )

        self.conn.commit()
        cur.close()

    def insert_authors(self):
        cur = self.conn.cursor()
        for author in self.authors:
            if 'last_name' in author:
                cur.execute("INSERT INTO zotero_cites_to_authors(zotero_key, author_type, name, last_name, first_name) VALUES (%s, %s, %s, %s, %s)", (self.cite['zotero_key'], author['creator'], author['name'], author['last_name'], author['first_name']))
            else:
                cur.execute("INSERT INTO zotero_cites_to_authors(zotero_key, author_type, name) VALUES (%s, %s, %s)", (self.cite['zotero_key'], author['creator'], author['name']))
        self.conn.commit()
        cur.close()

    def insert_keywords(self):
        cur = self.conn.cursor()
        for kw in self.keywords:
            cur.execute("INSERT INTO zotero_keywords(zotero_key, keywords) VALUES (%s, %s)", (self.cite['zotero_key'], kw))
        self.conn.commit()
        cur.close()

    def get_db(self):
        """
        Get a database connection

        With a host attribute in the mix, you could connect to a remote
        database, but then you would have to set up .pgpass or add a
        password parameter, so let's keep it simple.
        """

        try:
            self.conn = psycopg2.connect(
                database=self.config['database']['dbname'],
                user=self.config['database']['dbuser']
            )
        except Exception as e:
            print(e)

def get_db(config):
    """
    Get a database connection

    With a host attribute in the mix, you could connect to a remote
    database, but then you would have to set up .pgpass or add a
    password parameter, so let's keep it simple.
    """

    try:
        conn = psycopg2.connect(
            database=config['database']['dbname'],
            user=config['database']['dbuser']
        )
    except Exception as e:
        print(e)

    return conn

def prep_db(config):
    "Extend the database to support richer Zotero API data"

    # We're going to start tracking the citations by their zotero key:

    stmts = [
        "ALTER TABLE citations ADD COLUMN zotero_key TEXT;",
        "ALTER TABLE citations ADD COLUMN source JSONB;"
    ]

    # This will enable us to insert the new citations, as well as a new
    # zotero_cites_to_authors table:

    stmts.append("CREATE TABLE zotero_cites_to_authors (zotero_key TEXT, author_type TEXT, name TEXT, first_name TEXT, last_name TEXT, author_id INT);")

    # Then we'll be able to normalize the authors with the existing authors table
    # (updating author_id), then map the authors to citations by ID in the
    # cites_to_author table.

    # We also want to automatically assign IDs for the new citations (6533 is the latest):
    stmts.append("CREATE SEQUENCE citations_id_seq;")
    stmts.append("SELECT SETVAL('citations_id_seq', MAX(id) + 1) FROM citations;")
    stmts.append("ALTER TABLE citations ALTER COLUMN id SET DEFAULT nextval('citations_id_seq');")

    # Prevent duplicate author/citation rows from new citations
    stmts.append("ALTER TABLE cites_to_authors ADD CONSTRAINT unique_cites_to_authors UNIQUE (citation, author_type, author);")

    conn = get_db(config)
    cur = conn.cursor()
    for stmt in stmts:
        cur.execute(stmt)
    conn.commit()
    cur.close()


def main():
    "Integrate the latest updates to the database"

    config = configparser.ConfigParser()
    config.read(abspath(dirname(__file__)) + '/config.ini')

    try:
        prep_db(config)
    except Exception as e:
        print(e)

    stop_date = datetime.datetime.strptime(config['zotero']['stop_date'], "%Y-%m-%d")

    # Access our group
    zot = zotero.Zotero(config['zotero']['group'], 'group', config['zotero']['key'])

    # list_collections(zot)
    items = zot.items(sort='dateModified', direction='desc', limit=100)
    # items = [zot.item('JC94RN9H')]
#    import requests
#    r = requests.get('https://api.zotero.org/groups/290262/items/2P9NSQ9M')
#    items = []
#    items.append(r.json())

    mod_date = datetime.datetime.now()
    while items and stop_date < mod_date:
        for i in items:
            #print(json.dumps(i, sort_keys=True, indent=4))
            #print("%s %s" % (i['key'], i['data']['dateModified']))
            if i['data']['itemType'] == 'attachment':
                continue
            mod_date = datetime.datetime.strptime(i['data']['dateModified'], '%Y-%m-%dT%H:%M:%SZ')
            if stop_date > mod_date:
                continue
            process_item(i, config)
        items = zot.follow()

def process_item(i, config):
    "Parse the item data and get it into the database"
    z = ZoteroParser(i, config)

    stop_date = datetime.datetime.strptime(config['zotero']['stop_date'], "%Y-%m-%d")

    if z.add_date < stop_date:
        z.insert_authors()
        z.insert_keywords()
        z.update_citation()
        z.conn.close()
    else:
        z.insert_authors()
        z.insert_keywords()
        z.insert_citation()
        z.conn.close()

def list_collections(zot):
    "We have a lot of collections"
    c = zot.collections()
    x = 0
    for i in c:
        x += 1
        print(json.dumps(i, sort_keys=True, indent=4))
    c = zot.collections(start=x)
    for i in c:
        x += 1
        print(json.dumps(i, sort_keys=True, indent=4))
    c = zot.collections(start=x)
    for i in c:
        x += 1
        print(json.dumps(i, sort_keys=True, indent=4))
    print(x)


if __name__ == '__main__':
    main()
