#!/usr/bin/env python3

# Build a structure like so (or better, stream it, avoiding memory pressure):
# {
#   1, [
#         {"TY", "JOUR"},
#         {"TI", "#1 mine remembered"},
#         {"AU", "Stonebanks, Roger"},
#         {"KW", "History"}
#      ]
#   2, [ [] ]
# }
#
# Then iterate over all of the objects, dumping output into appropriate files:
#
# for rec in record:
#     if 

import os
import sys

class RISParser:

    # We expect each of these fields to appear only once for a given citation
    core_map = {
        'AB': 'abstract',
        'DA': 'pub_date',
        'DP': 'pub_database',
        'SP': 'start_page',
        'EP': 'end_page',
        'LA': 'language',
        'CN': 'call_number',
        'CY': 'pub_place',
        'M3': 'work_type',
        'PB': 'publisher',
        'PY': 'pub_year',
        'TY': 'doc_type', # type of the cited document
        'TI': 'title',
        'T2': 'title2',
        'T3': 'title3',
        'J2': 'alternate_title', # often abbrev. journal or book title
        'ST': 'short_title', # often abbrev. journal or book title
        'DO': 'doi',
        'UR': 'url',
        'L2': 'local_url',
        'SN': 'isbn_issn',
        'ET': 'edition',
        'M1': 'id_number',
        'IS': 'issue_number',
        'VL': 'volume',
        'Y2': 'access_date'
    }

    # multiple authors per citation
    author_map = {
        'AU': 'first',
        'A2': 'secondary',
        'A3': 'tertiary',
        'A4': 'quaternary'
    }

    skip_keys = ('L1', 'L4')

    def __init__(self, ris_f="cawls.ris", core_f="core.sql", authors="authors.sql", kw_f="keywords.sql", notes_f="notes.sql"):
        self.rec = 0
        self.core = {}
        self.init_core()
        self.ris_f = open(ris_f, "r")
        self.core_f = open(core_f, "w")
        self.authors_f = open(authors, "w")
        self.kw_f = open(kw_f, "w")
        self.notes_f = open(notes_f, "w")
        self.sql_header_core()
        self.sql_header_authors()
        self.sql_header_keywords()
        self.sql_header_notes()
        self.sql_core_adds = [
            "UPDATE ris_core SET isbn_issn = regexp_replace(isbn_issn, '^(\d{4})(\d{4})$', '\\1-\\2') WHERE isbn_issn ~ '^\d{8}$';",
            "ALTER TABLE ris_core ADD COLUMN kw_tsv TSVECTOR;",
            """UPDATE ris_core SET kw_tsv = setweight(to_tsvector('english', title), 'A')
                 || setweight(to_tsvector('english', COALESCE(abstract, '')), 'C')
                 || setweight(to_tsvector('english', COALESCE(
                    (SELECT notes FROM ris_notes WHERE citation = id), '')), 'C')
                 || setweight(to_tsvector('english', COALESCE(
                    (SELECT keywords FROM ris_keywords WHERE citation = id), '')), 'B');""",
            "DROP FUNCTION IF EXISTS ris_search(TEXT);",
            "DROP TYPE IF EXISTS search_result CASCADE;",
            "CREATE TYPE search_result AS (citation INT, title TEXT, rank REAL);",
            r"""CREATE FUNCTION ris_search(query TEXT) RETURNS SETOF search_result AS $$
                 SELECT id, title, ts_rank_cd(kw_tsv, to_tsquery(query))
                 FROM ris_core
                WHERE kw_tsv @@ to_tsquery(query)
                ORDER BY 3 DESC$$ LANGUAGE SQL;""",
            r"""CREATE OR REPLACE FUNCTION ris_filter(att TEXT, val TEXT)
                RETURNS SETOF search_result AS $$
                DECLARE
                    sql TEXT := 'SELECT id, title, 0::REAL FROM ris_core
                        WHERE ' || quote_ident(att) || ' = $2';
                BEGIN
                    RETURN QUERY EXECUTE sql USING att, val;
                END;
                $$ LANGUAGE PLPGSQL;"""
        ]

    def init_core(self):
        self.authors = [] 
        self.keywords = [] 
        self.notes = []
        self.lastkey = "" 
        self.lastval = ""
        for v in RISParser.core_map.values():
            self.core[v] = None

    def sql_header_core(self, table='ris_core'):
        sql = "DROP TABLE IF EXISTS %s; CREATE TABLE %s(id INTEGER, " % (table, table)
        for key in sorted(self.core_map.keys()):
            sql = sql + "%s TEXT, " % (self.core_map[key])
        sql = sql[0:-2] + ");\n"

        sql = sql + "COPY %s (id, " % (table)
        for key in sorted(self.core_map.keys()):
            sql = sql + "%s, " % (self.core_map[key])
        sql = sql[0:-2] + ") FROM STDIN;\n"
        self.core_f.write(sql)

    def sql_header_authors(self, table="authors"):
        sql = """
            DROP TABLE IF EXISTS ris_authors;
            CREATE TABLE ris_authors(id SERIAL, citation INTEGER, 
                author_type TEXT, author_name TEXT, uri TEXT);
            COPY ris_authors(citation, author_type, author_name)  FROM STDIN;
        """
        self.authors_f.write(sql)

    def sql_header_keywords(self, table="keywords"):
        sql = "DROP TABLE IF EXISTS ris_keywords;\n" \
            + "CREATE TABLE ris_keywords(id SERIAL, citation INTEGER, " \
            + "keywords TEXT);\n" \
            + "COPY ris_keywords(citation, keywords) FROM STDIN;\n"
        self.kw_f.write(sql)

    def sql_header_notes(self, table="notes"):
        sql = "DROP TABLE IF EXISTS ris_notes;\n" \
            + "CREATE TABLE ris_notes(id SERIAL, citation INTEGER, " \
            + "notes TEXT);\n" \
            + "COPY ris_notes(citation, notes) FROM STDIN;\n"
        self.notes_f.write(sql)

    def close_sql(self):
        for f in (self.core_f, self.authors_f, self.kw_f, self.notes_f):
            f.write("\\.\n")
        for line in self.sql_core_adds:
            self.core_f.write(line)
            self.core_f.write("\n")

    def parse(self, line):
        if len(line) == 1:
            pass
        elif line[0:-1] == 'ER  - ':
            self.printem()
        elif line[2:6] == '  - ':
            self.store()
            self.lastkey = line[0:2]
            self.lastval = line[6:].strip()
        else:
            self.lastval = "\\n".join((self.lastval, line[0:].strip()))

    def printem(self):
        self.write_core()
        self.write_authors()
        self.write_keywords()
        self.write_notes()
        self.init_core()
        self.rec += 1

    def write_core(self):
        self.core_f.write("%d" % (self.rec))
        for key in sorted(self.core_map.keys()):
            val = self.core[self.core_map[key]]
            if not val:
                val = "\\N"
            val = val.replace('\t', ' ')
            self.core_f.write("\t%s" % (val))
        self.core_f.write("\n")
        
    def write_authors(self):
        for x, y in self.authors:
            self.authors_f.write("%d\t%s\t%s\n" % (self.rec, x, y))

    def write_keywords(self):
        for x in self.keywords:
            self.kw_f.write("%d\t%s\n" % (self.rec, x))

    def write_notes(self):
        for x in self.notes:
            self.notes_f.write("%d\t%s\n" % (self.rec, x))

    def store(self):
        if self.lastkey in RISParser.core_map:
            self.core[RISParser.core_map[self.lastkey]] = self.lastval
        elif self.lastkey in RISParser.author_map:
            self.authors.append(([RISParser.author_map[self.lastkey], self.lastval]))
        elif self.lastkey == 'KW':
            self.keywords.append(self.lastval)
        elif self.lastkey == 'N1':
            self.notes.append(self.lastval)
        elif self.lastkey in RISParser.skip_keys:
            pass
        elif self.lastkey:
            print("Undefined key: ", self.lastkey)

    def parsefile(self):
        with self.ris_f as f:
            for line in f:
                self.parse(line)
        self.close_sql()

if __name__ == "__main__":
    foo = RISParser(ris_f="cawls.ris", core_f="core.sql", authors="authors.sql", kw_f="keywords.sql", notes_f="notes.sql")
    foo.parsefile()
